# JavaScript

[TOC]

**JS代码需要编写到script标签中**

**prompt()可以用来获取用户输入的内容，它会将用户输入的内容以字符串的形式返回，可以通过变量来接收**

## 1.输出语句

alert("输出的内容"):在弹出的警告框显示内容

console.log('输出的内容'):在控制台输出内容

document.write('内容'):向网页(body)当中输出内容

## 2.编写位置

1.可以将JS编写到网页内部的script标签中

2.写到外部的js文件

3.可以将js代码编写到指定属性中

## 3.基本语法

```js
/*
	1.多行注释
*/
//2.单行注释
```

3.JS严格区分大小写

4.在JS中多个空格和换行会被忽略，可以利用这个特点对代码进行格式化

5.JS中每条语句都应该以分号结尾JS中具有自动添加分号的机制，所以如果不写分号解释器会自动添加

## 3.字面量

字面量其实就是一个值，它所代表的含义就是字面意思。比如:1 2 100 "hello" true null...

在JS中所有的字面量都可以直接使用，但是直接使用字面量不方便

## 4.变量

变量可以用来"存储"字面量，变量中存储的字面量可以随意的修改。通过变量可以对字面量进行描述，并且变量方便修改

### 变量的使用

声明变量 --> let 变量名(有块作用域) / var 变量(无块作用域但有函数作用域)

变量赋值 --> a = xx

声明和赋值同时进行 --> let 变量 = 值

### 变量的内存结构

内存中会有专门的区域用来存变量

内存中单独开辟出一个新的空间专门用来存储变量的值(不会重复去创建相同的数据)

每一个内存当中的数据都有一个唯一的内存地址，通过内存地址就可以找到内存中的数据，变量并不存储任何值而是存储值的内存地址

## 5.常量

在JS中，使用const声明常量，常量只能赋值一次，重复赋值会报错

在JS中除了常规的常量，有一些对象类型的数据也会声明常量

## 6.标识符

在JS中，所有可以由我们自主命名的内容，都可以认为是一个标识符。像变量名、函数名、类名...

使用标识符需要遵循以下的命名规范:

1.标识符只能含有字母、数字、下划线、$,且不能数字开头

2.标识符不能是JS中的关键字和保留字，也不建议使用内置的函数或类名作为变量名

3.命名规范: 

- 通常会只用驼峰命名法（首字母小写，每个单词开头大写） 

  ​	--maxlength-->maxLength

- 类名会使用大驼峰命名法（首字母大写，每个单词开头大写）

  ​	--maxlength-->MaxLength

- 常量的字母会全部大写

## 7.数据类型

JS中原始值一共有7种，七种原始值是构成各种数据的基石，原始值在JS中是不可变类型，一旦创建就不能修改

typeof用来检查不同的值的类型，它会根据不同的值返回不同的结果

### 1.数值(number)

- 在JS中所有的整数和浮点数都是Number类型
- JS中的数值并不是无限大，当数值超过一定范围后会显示近似值
- Infinity 是一个特殊的数值表示无穷
- 在JS中进行一些一些精读比较高的运算时要十分注意
- NaN（Not a Number）也是一个特殊的数值,表示非法的数值
- 二进制 0b1010
- 八进制 0o10
- 十六进制 0xff
- 输出都会以十进制显示

### 2.大整数(Big Int)

- 大整数用来表示一些比较大的整数
- 大整数使用n结尾
- 可以表示的数字范围是无限大的(以内存为依据)

### 3.字符串(String)

- 在JS中使用单引号或双引号表示字符串
- 转义字符 \   :  \" , \'  , \\  ,  \t --> 制表符,  \n --> 换行
- 引号不能跨行
- 模板字符串使用反单引号`来表示模板字符串(能够跨行使用)，模板字符串中可以嵌入变量
- 使用typeof检查一个字符串时会返回一个"string"

### 4.布尔值(Boolean)

- 布尔值主要用来进行逻辑判断
- 使用typeof检查一个布尔值时会返回"boolean"

### 5.空值(Null)

- 空值用来表示空对象
- 空值只有一个null
- 使用typeof检查一个空值时会返回object
- 使用typeof无法检查空值

### 6.未定义(Undefined)

- 当声明一个变量而没有赋值时，它的值就是Undefined
- Undefined类型的值只有一个就是undefined
- 使用typeof检查一个Undefined类型的值时，会返回"undefined"

### 7.符号(Symbol)

- m=用来创建一个唯一标识
- 使用typeof检查符号时会返回"symbol"

### 8.类型转换

- 类型转换将一种数据类型转换为其他类型
- 主要指将其他类型转换成（字符串、数值和布尔值）

#### 转换为字符串

1.调用toString()方法将其他类型转换为字符串

- 调用xxx的yyy方法   --->   xxx.yyy()

- 由于hull 和 undef中没有toString()，所以对这两个调用toString()时会报错

2.调用String()函数将其他类型转换为字符串

- 调用xxx函数   --->  xxx()
- 原理:对于拥有toString()方法的值调用String()函数时，实际上就是在调用toString()方法。对于null，则直接转换为"null";对于undefined，直接转换为"undefined"

#### 转换为数值

将其他类型转换为数值

1.使用Number()函数来将其他类型转换为数值

- 转换的情况:
- 字符串:如果字符串是一个合法的数字，则会自动转换为对应的数字；如果字符串不是合法数字，则转换为NaN；如果字符串是空串或纯空格的字符串，则转换为0
- 布尔值:true转换为1；false转换为0
- null: 0
- undefined: NaN

2.专门用来将字符串转换为数值的两个方法

- parseInt() --- 将一个字符串转换为一个整数，可以对浮点数进行取整
- parseFloat()  ---  将一个字符串转换为浮点数
- parse(解析)解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数/浮点数

#### 转换为布尔值

1.使用Boolean()函数来将其他类型转换为布尔值

转换的情况:

- 数字: 除了0和NaN转换为false，其余为true
- 字符串:空串转换为false，其余为true
- null 和 undefined 都转换为 false
- 对象:对象都会转换为true

所有表示空性的、没有的、错误的值都会转换为false

## 8.运算符(操作符)

运算符可以用来对一个或多个值进行运算

### 算术运算符

- +
- -
- *
- /
- **  幂运算(也可以用这个进行开放)
- % 取余

注意:

- 算术运算时，除了字符串的加法，其他运算的操作数是非数值，都会准换为数值再运算
- 当任意一个值和一个字符串做加法运算时，它会将其他值转换为字符串，然后再做拼串的操作。可以利用这个特点进行类型转换:可以通过为任意类型 + 一个空串的形式来将其转换成字符串，其原理和String()函数相同，但使用起来更加简洁

### 赋值运算符

赋值运算符用来将一个值赋值给一个变量

一个变量只有在"="左边时才是变量，在"="右边时它是值

- =    把右边的值赋给左边的变量
- ??=   空赋值只有当变量的值为null或undefined时才会进行赋值
- +=  (c语言相同用法)
- -=
- *=
- /=
- %=
- **=

### 一元±

- +正号， 不会改变数值的符号
- -负号， 可以对数值进行符号位取反
- 当我们对非数值类型进行正负运算时，会先将其转换为数值然后再运算

### 自增和自减(和c语言功能一样)

#### ++ 自增运算符

- ++使用后会使原来的变量立刻增加1
- 自增分为前自增(++a)和后自增(a++)

#### -- 自减运算符

- --使用后会使原来的变量立刻减小1
- 自增分为前自增(--a)和后自增(a--)

### 逻辑运算符(类似于c语言)

- ! 逻辑非   可以用来对一个值进行非运算，可以对一个布尔值进行取反。如果对一个非布尔值进行取反，会先将其转换为布尔值然后再取反。可以利用这个特点将其他类型转换为布尔值 --->  !!
- && 逻辑与 可以对两个值进行与运算。当&&左右都为true时，则返回true，否则返回false。与运算是短路的与，如果第一个值是false，则不看第二个值。对非布尔值进行与运算，会转换为布尔值然后运算，但是最终会返回原值。**如果第一个值为false则直接返回第一个值，如果第一个值为true，则返回第二个值**
- || 逻辑或 可以对两个值进行或运算。当左右有true时则返回true，否则返回false。或运算也是短路的或，如果第一个值为true,则不看第二个值。或运算是找true，如果找到true则直接返回，没有true才会返回false。对于非布尔值或运算，它会转换为布尔值然后运算，但是最终会返回原值。**如果第一个值为true，则返回第一个，如果第一个值为false则返回第二个值**

### 关系运算符

用来检查两个值之间的关系是否成立，成立返回true，不成立返回false

- #### >  

- <

- <=

- ">="

当对非数值进行关系运算时，它会先其转换为数值然后再比较

当关系运算符的两端是两个字符串，它不会将字符串转换为数值，而是**逐位**地比较字符的Unicode编码，利用这个特点可以对字符串按照字母排序

注意比较两个字符串格式的数字时一定要进行类型转换

### 相等运算符

- ==  相等运算符，用来比较两个值是否相等。**使用相等运算符比较两个不同类型的值时，它会将其转换为相同的类型(通常转换为数值)，然后再比较**，类型转换后值相同也会返回true。**null和undefined进行相等比较时会返回true。NaN不和任何值相等，包括它自身**。
- === 全等运算符，用来比较两个值是否全等。不会进行自动的类型转换，如果两个值的类型不同则直接返回false。null和undefined进行全等比较时会返回false
- != 不等，用来检查两个值是否不相等，会自动的进行类型转换
- !== 不全等 比较两个值是否不全等，不会自动的类型转换

### 条件运算符

条件表达式 ? 表达式1 : 表达式2

执行顺序:

- 条件运算符在执行时，会先对条件表达式进行求值判断:如果结果为true，则只想表达式1，如果结果为false，则进行表达式2

## 9.流程控制

使用{}来创建代码块，代码块可以用来对代码进行分组。同一个代码块中的代码就是同一组代码，一个代码块中的代码要么都执行要么都不执行。

let 和 var

- 在JS中，使用let声明的变量具有块作用域，在代码块中声明的变量无法在代码块的外部访问
- 使用var声明的变量不具有块作用域

流程控制语句可以用来改变程序执行的顺序

### 条件判断语句(类似c)

#### if语句

- 语法:if(条件表达式)

  ​			   语句

- 执行流程：

  ​		if语句在执行会先对if后的条件表达式进行求值判断，如果结果为true，则执行if后的语句，如果结果为false则不执行

  ​		if语句只会控制紧跟其后的那一行代码，如果希望可以控制多行代码，可以使用{}将语句括起来

  ​		如果if后的添加表达式不是布尔值，会转换为布尔值然后再运算

#### if-else语句

- 语法:

  ​	if(条件表达式){

  ​			语句...

  ​	}else{

  ​			语句...

  ​	}

- 执行流程：

  ​	if-else执行时，先对条件表达式进行求值判断，如果结果为true，则执行if后的语句,如果结果为false，则执行else后的语句。

### if-else if-else

- 语法:

  ​	if(条件表达式){

  ​			语句...

  ​	}else if(条件表达式){

  ​			语句...

  ​	}else if(条件表达式){

  ​			语句...

  ​	}else if(条件表达式){

  ​			语句...

  ​	}else{

  ​			语句...

  ​	}

- 执行流程: if-else if-else语句，会自上而下依次对if后的条件进行求值判断，如果条件表达式为true，则执行当前if后的语句，执行完毕语句结束；如果条件表达式为false，则继续向下判断，直到找到true为止；如果所有的条件表达式都为false，则执行else后的语句

### 条件分支语句

#### switch语句

- 语法:switch(表达式){

  ​			case 表达式:

  ​					代码...

  ​			case 表达式:

  ​					代码...

  ​			...

  ​		}

- 执行的流程:switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较。如果比较结果为true，则自当前case处开始执行代码。如果比较结果为false，则继续比较其他case后的表达式，直到找到true为止。如果所有的比较都是false，则执行default后的语句

- 注意:当比较结果为true时，会从当前case处开始执行代码，也就是说case是代码执行的起始位置。意味着只要是当前case后的代码，都会执行。可以使用break来避免执行其他的case

### 循环语句

通过循环语句可以使指定的代码反复执行

#### while语句

while(条件表达式){

​		语句...

}

#### do-while语句

do{

​	语句..

}while(条件表达式)

#### for语句

for(初始化表达式；条件表达式；更新表达式){

​	语句...

}

### break和continue

#### break

- break用来终止switch和循环语句
- break执行后，当前的switch或循环会立刻停止
- break会终止离他最近的循环

#### continue

- continue用来跳过当次循环

## 10.对象

原始值只能用来表示一些简单的数值，不能表示复杂数据。

- 对象是js中的一种复合数据类型，相当于一个容器，在对象中可以存储各种不同类型数据
- 对象中可以存储多个各种类型的数值，对象中存储的数据，我们称为属性
- 创建对象 let a = Object()
- 向对象中添加属性:对象.属性名 = 属性值
- 读取对象中的属性: 对象.属性名，如果读取的是一个对象中没有的属性，不会报错，而是undefined
- 删除属性： delete a.name
- 使用typeof检查一个对象时，会返回object

### 对象的属性

#### 属性名

- 通常属性名就是一个字符串，所以属性名可以是任何值，但是如果属性名太特殊，不能直接使用，需要使用[]来设置，建议属性名也按照标识符的规范命名。
- 也可以使用符号(symbol)作为属性名，来添加属性，获取这种属性时，也必须使用symbol。使用symb添加的属性，通常是那些不希望被外界访问的属性
- 使用[]去操作属性时，可以使用变量，使用.去操作属性时，不能使用变量

#### 属性值

对象的属性值可以是任意的数据类型

#### in运算符

- 用来检查对象中是否含有某个属性
- 语法 属性名 in a
- 如果有返回true，没有返回false

### 对象字面量

- 可以直接使用{}来创建对象

- 使用{}所创建的对象，可以直接向对象中添加属性

- 语法:

  ​		{

  ​			属性名:属性值

  [属性名]:属性值

  ​		}

### 枚举属性

指将对象中的所有属性全部获取

#### for-in语句

- 语法:

  ​	for(let propName in 对象){

  ​		    语句

  ​	}

- for-in的循环体会执行多次，有几个属性就会执行几次，每次执行时，凑会将一个属性名赋值给我们所定义的变量

- 注意:并不是所有的属性都可以枚举，比如:使用符号添加的属性

### 可变类型

原始值都属于不可变类型，一旦创建不可修改

在内存中不会重复创建相同的原始值

对象属于可变类型

对象创建完成后，可以任意的添加删除修改对象中的属性

注意:

- 当对两个对象进行相等或全等比较时，比较的是对象的内存地址

- 如果有两个变量同时指向一个对象，通过一个变量修改对象时，对另外一个变量也会产生影响。
- 当修改一个对象时，所有指向该对象的变量都会受到影响

### 改变量和改对象

#### 修改对象

- 修改对象时，如果有其他变量指向该对象，则所有指向该对象的变量都会受到影响

#### 修改变量

- 修改变量时，只会影响当前的变量

在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const

注意:const只是禁止变量被重新赋值，对对象的修改没有任何影响。

### 方法

当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法，调用函数称为调用对象的方法

## 11.函数(Function)

函数也是一个对象，它具有其他对象所有的功能，并且函数中可以存储代码，且可以在需要时调用这些代码

- 语法:

  function 函数名(){

  ​		语句...

  }

- 调用函数:调用函数就是执行函数中存储的代码

- 语法:

  ​	函数对象()

- 使用typeof检查函数时会返回function

### 函数的定义方式

### 参数

#### 形式参数

- 在定义函数时，可以在函数中指定数量不等的形参
- 在函数中定义形参，则相当于在函数内部声明了对应的变量但是没有赋值

#### 实际参数

- 在调用函数时可以在函数的()内传递不等的实参
- 实参会赋值给对应的形参
- 如果实参和形参的数量相同，则对应的实参赋值给对应的形参
- 如果实参多于形参，则多余的实参不会使用
- 如果形参多于实参，则多余的形参赋值为undefined

#### 参数类型

- JS中不会检查参数的类型，可以传递任何类型的值作为参数
- 对象可以作为参数传递
- 传递实参时，传递的并不是变量本身，而是变量中存储的量

定义参数时，可以为参数指定默认值，默认值会在没有对应实参时生效，函数每次调用都会重新创建默认值

- 函数声明

  function 函数名([参数]){

  ​	语句...

  }

- 函数表达式

  ​	const 变量 = function([参数]){

  ​		语句...

  ​	}

- 箭头函数

  ​	([参数]) => {

  ​		语句...

  ​	}

  当箭头函数中只有一个参数时，可以省略()

### 函数的返回值

- 在函数中可以通过return关键字来指定函数的返回值，返回值是函数的执行结果，函数调用完毕返回值便会作为结果返回。
- 任何值都可以作为返回值使用(包括对象和函数之类)，如果return后不跟任何值，则相当于返回undefined。如果不写return，那么函数的返回值依然是undefined
- return一执行，函数立即结束
- 箭头函数的返回值可以直接写到箭头后，如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

### 作用域(scope)

作用域指的是一个变量的可见区域

作用域有两种:

- 全局作用域

  ​	全局作用域在网页运行时创建，在网页关闭时消耗

  ​	所有直接编写到script标签中的代码都位于全局作用域

  ​	全局作用域中的变量是全局变量，可以在任意位置访问

- 局部作用域

  ​	块作用域

  ​		块作用域是一种局部作用域

  ​		块作用域在代码块执行时创建，代码块执行完毕它就销毁

  ​		在块作用域中声明的变量时局部变量，只能在块内部访问，外部无法访问

  ​	函数作用域

  ​		函数作用域也是一种局部作用域

  ​		函数作用域在函数调用时产生，调用结束后销毁

  ​		函数每次调用都会产生一个全新的函数作用域

  ​		在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

#### 作用域链

当我们使用一个变量时，JS解释器会优先在当前作用域中寻找变量，如果找到了则直接使用；如果没找到，则去上一层作用域中寻找，找到了则使用；如果一直到全局作用域都没找到，则报错 xxx is not defined

### window对象

在浏览器中，浏览器为我们提供了一个window对象，可以直接访问

window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象

window对象的属性可以通过window对象访问，也可以直接访问

**向window对象中添加的属性会自动成为全局变量**。

在全局中使用var声明的变量，都会作为window对象的属性保存；使用function声明的变量，都会作为window的方法保存

用let声明的变量不会存储在window，而存在一个秘密的小地方(无法访问)(doge)

**在局部作用域中，如果没有使用var或let声明变量，则变量会自动成为window对象的属性，也就是全局变量**。

### 提升

#### 变量的提升

使用var声明的变量，它会在所有代码执行前被声明，所以我们可以在声明变量前就访问变量

let声明的变量实际也会提升，但是在赋值之前解释器禁止访问该变量

#### 函数的提升

使用函数声明创建的函数，会在其他代码执行前被创建所以我们可以在函数声明前调用函数

### 立即执行函数(IIFE)

希望可以创建一个只执行一次的匿名函数

立即是一个匿名的函数，并且它只会调用一次；可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

### this

在函数执行时，JS解析器每次都会传递进一个隐含的参数，这个参数叫做this。

this会指向这个对象，this所指向的对象会根据函数调用方式的不同而不同

- 以函数形式调用时，this指向的是window
- 以方法的形式调用时，this指向的是调用方法的对象

通过this可以在方法中引用调用方法的对象

#### 箭头函数中的this

箭头函数没有自己的this，它的this由外层作用域决定；箭头函数的this和它的调用方式无关

### 严格模式

JS运行代码的模式有两种

- 正常模式：默认情况下代码都运行在正常模式中，在正常模式中语法检查并不严格，它的原则是:能不报错的地方尽量不报错。这种处理方式导致代码的运行性能较差

- 严格模式:在严格模式下，语法检查变得严格

  ​	1.禁止一些语法

  ​	2.更容易报错

  ​	3.提升了性能

在开发中，应该尽量使用严格模式，这样可以将一些隐藏的问题消灭在萌芽阶段，同时也可以提升代码的运行性能

"use strict"开启严格模式

## 12.面向对象

面向对象的特点:封装、继承和多态

### 面向对象编程(OOP)

- 程序就是对现实世界的抽象
- 一个事物抽象到程序中就变成了对象，在程序的世界中一切皆为对象
- 面向对象的编程指程序中的所有操作都是通过对象来完成，做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

#### 对象

- 一个事物通常由两部分组成:数据和功能
- 一个对象由两部分组成:属性和方法
- 事物的数据到了对象中，体现为属性
- 事物的功能到了对象中，体现为方法

对象的分类

- 内建对象
  - 由ES标准所定义的对象
  - 比如Object Function String Number
- 宿主对象
  - 有浏览器提供的对象
  - BOM,DOM
- 自定义对象
  - 由开发人员自己创建的对象

### 类

使用Object创建对象的问题:

- 无法区分出不同类型的对象
- 不方便批量创建对象

在JS中可以通过类(class)来解决这个问题:

- 类是对象模板，可以将对象中的属性和方法直接定义在类中，定义后就可以直接通过类来创建对象
- 通过同一个类创建的对象称为同类对象，可以使用instanceof来检查一个对象是否是由某个类创建的。如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

语法:

- class 类名 {}    //类名要使用大驼峰命名
- const 类名 = class {}

通过类创建对象

- new 类()

类的代码块默认就是严格模式。类的代码块是用来设置对象的属性的，不是什么代码都能写

### 属性

实例属性只能通过实例访问

使用static声明的属性是静态属性(类属性)，静态属性只能通过类进行访问

### 方法

添加方法的方式

- 方法名 = function(){}
- 方法名(){}   //实例方法，实例方法中的this就是当前实例
- static 方法名(){}  // 静态方法，通过类来调用，静态方法中的this指向的是当前类

### 构造函数

我们在类中直接指定实例属性的值时，意味着我们所创建的所有对象的属性都是这个值

在类中可以添加一个特殊的函数constructor，该方法称为构造函数(构造函数)，构造函数会在我们调用类创建对象的时候执行。可以在构造函数中为实例进行赋值，在构造函数中，this表示当前所创建对象

### 封装(安全性)

对象就是一个用来存储不同属性的容器，对象不仅负责属性，还要负责数据的安全，直接添加到对象中的属性，并不安全，因为它们可以被任意的值修改

如何确保数据的安全:

- 私有化数据:实例使用#开头就变成了私有属性，私有属性只能在类内部访问
  - 将需要保护的数据设置为私有，只能在类内部使用
- 提供setter和getter方法来开放对数据的操作
  - 属性设置私有，通过gerrer setter方法操作属性带来的好处
    - 可以控制属性的读写权限
    - 可以在方法中对属性的值进行验证

封装主要用来确保数据的安全

实现封装的方式:

- 属性私有化  加#

- 通过getter和setter方法来操作数据

  ​	get 属性名(){

  ​		return this.#属性

  ​	}

  ​	set 属性名(参数){

  ​		this.#属性 = 参数

  ​	}

### 多态(灵活性)

- 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
- 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
- 多态为我们提供了灵活性

### 继承(扩展性)

- 可以通过extends关键字来完成继承
- 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类当中(简单理解)
- 继承发生时，被继承的类称为父类(超类)，继承的类称为子类
- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对齐进行扩展
- 在子类中，可以通过创建同名方法来重写父类的方法
- 重写构造函数时，构造函数的第一行代码必须为super()来调用父类的构造函数
- 通过继承可以在不修改一个类的情况下对其进行扩展
- OCP 开闭原则
  - 程序中应该对修改关闭，对扩展开放

### 对象的结构

对象中存储属性的区域实际有两个:

- **对象自身**
  
  - 直接通过对象所添加的属性，位于对象自身中
  - 在类中通过 x = y 的形式添加的属性，位于对象自身中
  
- **原型对象(prototype)**

  - 对象中还有一些内容，会存储到其他的对象(原型对象)里
  - 在对象中会有一个属性用来存储原型对象，这个属性叫做_ proto _
  - 原型对象也负责为对象存储属性

    - 当我们访问对象中的属性时，会优先访问对象自身的属性，对象自身不包含该属性时才会去原型对象中寻找
  - **会添加到原型对象中的情况**:
    1. 在类中通过 xxx(){} 方式添加的方法，位于原型中
    2. 主动向原型中添加的属性或方法
  
  - **访问一个对象的原型对象**
  
    - 对象.__ proto__

    - Object.getPrototypeOf(对象)

  - **原型对象中的数据:**
  
    - 对象中的数据(属性，方法等)
  
    - constructor(对象的构造函数)
  
  - **注意:**
  
    - 院校对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同
  
      -  p对象的原型链:p对象 --> 原型 --> null
      - obj对象的原型链:obj对象 --> 原型 --> null
  
    - **原型链**
  
      - 读取对象属性时，会优先对象自身属性，
  
        - 如果对象中有，则使用，没有则去对象的原型中寻找
  
        - 如果原型中有，则使用，没有则去原型的原型中寻找
  
        - 知道找到object对象的原型(Object的原型没有原型(为null))
  
          - 如果依然没有找到，则返回undefined
  
            
  
      - 作用域链，是找变量的链，找不到会报错
  
      - 原型链，是找属性的链，找不到会返回undefined
  
  - 所有的同类型对象他们的原型对象都是同一个，也就意味着，同类型对象的原型链是一样的
  
  - **原型的作用:**
  
    - 原型就相当于是一个公共的区域，所有的公共属性(方法)统一存储到原型中。这样我们只需要创建一个属性即可被所有实例访问
    - JS中继承就是通过原型来实现的
      - 当继承时，子类的原型就是一个父类的实例
  
  - 在对象中有些属性是对象独有的，像属性(name,age,gender)每个对象都应该有自己的值，但是对于有些值对于每对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建
  - **修改原型**
    - 大部分情况下，我们不需要修改原型对象
    - 通过对象修改原型，向原型中添加方法，修改后所有同类实例都能访问该方法
      - 注意:
        - 千万不要通过类的实例去修改原型
          1. 通过一个对象影响所有同类对象这么做不合适
          2. 修改原型先得创建实例，麻烦
          3. 危险
    - 处理通过__ proto__能访问对象的原型外，还可以通过类的prototype属性，来访问实例的原型，修改原型时最好通过类去修改
      - 好处:
        1. 一修改就是修改所有实例的原型
        2. 无需创建实例即可完成对类的修改
      - 原则:
        1. 原则尽量不要手动改
        2. 要改也不要通过实例对象去改
        3. 通过类.orototype属性去修改
        4. 最好不要直接给prototype去赋值

### Instanceof

instanceof用来检查一个对象是否是一个类的实例

- instanceof检查的是对象的原型链上是否有该类实例
  - 只要圆形脸上有该类实例，就会返回true
  - Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true

### in

使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true

### 对象.hasOwnProperty(属性名)(不推荐使用)

用来检查一个对象的自身是否含有某个属性

### Object.hasOwn(对象， 属性名)

用来检查一个对象的自身是否含有某个属性

### 旧类

早期JS中，直接通过函数来定义类

- 一个函数如果直接调用xxx()那么这个函数就是一个普通函数
- 一个函数如果通过new调用new xxx()那么这个函数就是一个构造函数

向原型中添加属性(方法)

静态方法

类名.staticProperty = "xxx"

静态属性

类名.staticMethod = function(){}

### new

new运算符是创建对象时使用的运算符

- 当使用new去调用一个函数时，这个函数将会作为构造函数调用
  1. 创建一个普通的JS对象(Object对象{})，为了方便，称其为新对象
  2. 将构造函数的prototype属性设置为新对象的原型
  3. 使用实参执行构造函数，并且将新对象设置为函数中的this
  4. 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回(千万不要这么做)；如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回，通常不会为构造函数指定返回值

## 13.数组(Array)

- 数组也是一种复合数据类型，在数组中可以存储对个不同类型的数据
- 数组中存储的是有序的数据，数字钟的每个数据都有一个唯一的索引，可以通过索引来操作获取数据
- 索引(index)是一组大于等于0的整数

### 创建数组

通过Array()来创建数组，也可以通过[]来创建数组

创建数组时尽量要确保数组中存储的数据的类型是相同的

### 向数组中添加元素

语法:

- 数组[索引] = [元素]

使用数组时，应该**避免非连续数组**，因为它性能不好

### 读取数组中的元素

语法:

- 数组[索引]
  - 如果读取了一个不存在的元素，不好报错而是返回undefined

### length

数组.length

获取数组长度，获取的实际值是数组的最大索引+1

向数组的最后添加元素:

- 数组[数组.length] = 元素

length是可以修改的

### 遍历数组

获取到数组中的每一个元素

### for-of语句

for-of语句可以用来遍历可迭代对象

语法:

- for(变量 of 可迭代的对象){}

  ​		语句...

  }

- 执行流程:

  - for-of的循环体会执行多次，数组中有几个元素就会执行几次，每次执行时都会将一个元素赋值给变量

### 数组的方法

#### Array.isArray()

用来检查一个对象是不是数组

#### .at()

根据索引获取数组中的指定元素

at可以接收负索引作为参数

#### concat()

非破坏性方法，不会影响原数组，而是返回一个新数组

用来连接两个或多个数组

#### indexOf()

获取元素在数组中第一次出现的索引

参数:

1. 要查询的元素
2. 查询的起始位置

#### lastindexOf()

获取元素在数组中最后一次出现的位置

**返回值:**

- 找到了则返回元素的索引
- 没有找到返回-1

#### join()

讲一个数组中的元素链接为一个字符串

["one", "two", "three", "four","two"] --> “one,two,three,four,two”

参数:

- 指定一个字符串作为连接符

#### slice()

用来截取数组(非破坏性方法)

参数:

1. 截取的起始位置(包括该位置)
2. 截取的结束位置(不包括该位置)
   - 第二个参数可以省略不写，如果省略则会一直截取到最后
   - 索引可以是负值，
   - 如果将两个参数全部省略，则可以对数组进行浅复制

#### push()

向数组的末尾添加一个或多个元素，并且返回新的长度

#### pop()

删除并返回数组的最后一个元素

#### unshift()

向数组的开头添加一个或多个元素，并返回新的长度

#### shift()

删除并返回数组的第一个元素

#### splice()

可以删除、添加、插入、替换数组中的元素

参数:

1. 删除的起始位置
2. 删除的数量
3. 要插入的元素

返回值: 返回被删除的元素

#### reverse()

反转数组

#### sort()

sort用来对数组进行排序(会改变原数组)

sort默认会将数组升序排序

注意:sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序可能会得到一个不正确的结果

参数:可以传递一个回调函数作为参数，通过回调函数来指定排序规则

- (a, b) => a - b 升序排序
- (a, b) => b - a 降序排序

#### forEach()

用来遍历数组

他需要一个回调函数作为参数，这个回调函数会被调用多次

- 数组中有几个元素，回调函数就会调用几次，每次调用，都会将数组中的数据作为参数传递

回调函数中有三个参数

1. element  当前的元素
2. index  当前元素的索引
3. array  被遍历的数组

#### filter()

非破坏性方法，不会影响原数组

将数组中符合条件的元素保存到一个新数组中返回

需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中

#### map()

根据当前数组生成一个新数组

需要一个回调函数作为参数，回调函数的返回值会成为新数组的元素

非破坏性方法

#### reduce()

可以用来讲一个数组中的所有元素整合为一个值

参数:

1. 回调函数，通过回调函数来指定合并的规则
2. 可选参数，初始值

### 对象的复制

复制必须要产生新的对象

当调用slice时，会产生一个新的数组对象

#### ...(展开运算符)

- 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
- 通过它也可以进行浅复制

#### Object.assign(目标对象, 被复制的对象)

将被复制的对象中的属性复制到目标对象里，并将目标对象返回

#### 浅拷贝(shallow copy)

- 通常对对象的拷贝都是浅拷贝，只对对象的浅层进行复制(只复制一层)
- 如果对象中存储的数据是原始值，那么拷贝的深浅是不重要
- 浅拷贝只会对对象本身进行复制，不会复制对象中的属性(或元素)

#### 深拷贝(deep copy)

- 深拷贝值不仅复制对象本身，还复制对象中的属性和元素
- 因为性能问题，深拷贝一般不太使用
- 用来深拷贝的方法:structuredClone()

## 14.DOM

Document Object Model文档对象模型

要使用DOM操作网页，我们需要浏览器至少得先给我一个对象才能去完成各种操作。

所以浏览器已经为我们提供了一个document对象，它是一个全局变量可以直接使用，document代表的是一整个网页

### document对象

document对象表示的是整个网页

document的原型链

- HTMLDocument -> Document -> EventTarget -> Object.prototype -> null

凡是在原型链上存在的对象和方法都可以通过Document去调用

部分属性:

- document.documentElement --> html根元素
- document.head --> head元素
- document.title --> title元素
- document.body --> body元素
- document.links --> 获取页面中所有的超链接

### 元素节点对象(element)

在网页中，每一个标签都是一个元素节点

#### 获取元素节点

- 通过document对象来获取元素节点
- 通过document对象来创建元素节点

通过document获取已有的元素节点

#### document.getElementById() 

- 根据id获取一个元素节点对象

#### document.getElementsByClassName() 

- 根据元素的class属性值获取一组节点对象
- 返回的是一个类数组对象
- 该方法返回的结果是一个实时更新的集合，当网页中新添加元素时，集合也会实时的刷新

#### document.getElementsByTagName()

- 根据标签名获取一组元素节点对象
- 返回的结果是可以实时更新的集合
- document.getElementsByTagName("*")获取页面中所有的元素

#### document.getElementByName()

- 根据name属性获取一组节点对象
- 返回一个实时更新的集合
- 主要用于表单项

#### document.querySelectorAll()

- 根据选择器去页面中查询元素
- 会返回一个类数组(不会实时更新)

#### document.querySelector()

- 根据选择器去页面中查询第一个符合条件的元素

#### 创建一个元素节点

document.createElement()

div元素的原型链: -> HTMLDivElement -> HTMLElement -> Element -> Node -> ...

- 根据标签名创建一个新节点

#### 通过元素节点获取其他节点的方法

- element.childNodes 获取当前元素的子节点(会包含空白的子节点)
- element.children 获取当前元素的子元素
- element.firstElementChild 获取当前元素的第一个子元素
- element.lastElementChild 获取当前元素的最后一个子元素
- element.nextElementSibling 获取当前元素的下一个兄弟元素
- element.previousElementSiblinh 获取当前元素的前一个兄弟元素
- element.parentNode 获取当前元素的父节点
- element.tagName 获取当前元素的标签名

### 文本节点

在DOM中网页中所有的文本内容都是文本节点对象，可以通过元素来获取其中的的文本节点对象，但是我们通常不会这么做

我们可以直接通过元素去修改其中的文本

- 修改文本的三个属性
  - element.textContent 获取或修改元素中的文本内容
    - 获取的是标签中的内容，不会考虑CSS样式
  - element.innerText 获取或修改元素中的文本内容
    - innerText获取内容时，会考录CSS样式
    - 通过innerText去读取CSS样式，会触发网页的重排(计算CSS样式)
    - 当字符串中有标签时，会自动对标签进行转义
  - element.innerHTML 获取或修改元素中的html代码
    - 可以直接向元素中添加html代码
    - innerHTML插入内容时有被XSS注入的风险

### 属性节点(Attr)

在DOM中也是一个对象，通常不需要获取对象而是直接通过元素即可完场对其的各种操作

#### 如何操作属性节点

- 方式一:
  - 读取: 元素.属性名(注意: class属性需要使用className)
    - 读取一个布尔值时，会返回true或false
  - 修改: 元素.属性名 = 属性值
- 方式二:
  - 读取: 元素.getAttribute(属性名)
  - 修改: 元素.setAttribute(属性名，属性值)
  - 删除: 元素.removeAttribute(属性名)

### 事件(event)

事件就是用户和页面之间发生的交互行为，比如:点击按钮、鼠标移动、双击按钮、敲击键盘、松开按键...

可以通过为事件绑定响应函数，来完成和用户之间的交互

绑定响应函数的方式:

- 可以直接在元素的属性中设置
- 可以通过元素的指定属性设置回调函数的形式来绑定事件(一个事件只能绑定一个响应函数)
- 通过元素的addEventListener()方法来绑定事件

### 文档的加载

网页是自上向下加载的，如果将js代码编写到网页的上边，js代码在执行中，网页还没有加载完毕这时会出现不发获取到DOM对象的情况

window.onload事件会在窗口中的内容加载完毕后执行

document的DOMContentLoaded事件会在当前文档加载完毕之后触发

如何解决

- 将script标签编写到body的最后
- 将代码编写到window.onload的回调函数中
- 将代码编写到document对象的DOMcontentLoaded的回调函数中(执行时机更早)
- 将代码编写到外部的js文件中，然后以defer的形式进行引入(执行时机更早，早于DOMContentLoaded)

### DOM的修改

#### appendChild()

用于给一个节点添加子节点

#### insertAdjacentElement()

可以向元素的任意位置添加元素

两个参数: 1.要添加的位置 2.要添加的元素

beforeend 标签的最后； afterbegin标签的开始；beforebegin在元素的前边插入元素(兄弟元素)； afterend 在元素的后边插入元素(兄弟元素)

#### replaceWith()

使用一个元素替换当前元素

#### remove()

用来删除当前元素

### 节点的复制

.cloneNode()  用来对节点进行复制的

使用cloneNode()方法对节点进行复制时，它会复制节点的所有特点包括各种属性

这个方法默认只会复制当前节点，而不会复制节点的子节点。可以传递一个true作为参数，这样该方法也会将元素的子节点一起复制

### 修改CSS样式

修改样式的方式: 元素.style.样式名 = 样式值

如果样式名中含有-，则需要将样式表修改为驼峰命名法:background-color --> backgroundColor

#### 修改class属性来间接修改样式

好处:

- 可以一次修改多个样式
- 对JS和CSS进行解耦

##### 元素.classList

元素.classList 是一个对象，对象中提供了对当前元素的类的各种操作方法

元素.classList.add() 向元素中添加一个或多个class

元素.classList.remove() 移除元素中一个或多个class

元素.classList.toggle() 切换元素中的class

元素.classList.replace() 替换class

元素.classList.contains() 检查class

### 读取CSS样式

#### getComputedStyle()

它会返回一个对象，这个对象中包含了当前元素所有生效的样式

参数:

- 要获取样式的对象
- 要获取的元素

返回值: 返回的一个对象，对象中存储了当前元素的样式

注意: 样式对象中返回的样式值，不一定能拿来直接计算，所以使用时，一定要确保值是可以计算的才去计算

#### 元素.clientHeight 和 元素.clientWidth

获取元素内部的宽度和高度(包括内容区和内边距)

#### 元素.offsetHeight 和 元素.offsetWidth

获取元素的可见框的大小(包括内容区、内边距和边框)

#### 元素.scollHeight 和 元素.scollWidth

获取元素滚动区域的大小

#### 元素.offsetParent

获取元素的定位父元素

定位父元素: 离当前元素最近的开启了定位的祖先元素，如果所有的元素都没有开启定位则返回body

#### 元素.offsetTop 和 元素.offsetLeft

获取元素相对于其定位父元素的偏移量

#### 元素.scrollTop 和 元素.scrollLeft

获取或设置元素滚动条的偏移

### 事件对象

event事件

事件对象是由浏览器在事件触发时所创建的对象，这个对象中封装了事件相关的各种信息；通过事件对象可以获取到事件的详细信息，比如: 鼠标的坐标、键盘的按键..

浏览器在创建事件对象后，会将事件对象作为响应函数的参数传递，所以我们可以在事件的回调函数中定义一个形参来接收事件对象

在DOM中存在多种不同类型的事件对象，多种事件对象有着一个共同的祖先 Event

- event.target
- event.currentTarget b绑定事件的对象(同this)
- event.stopPropagation() 停止事件的传导
- event.preventDefault() 取消默认行为

#### 事件的冒泡:

- 时间的冒泡就是指时间的向上传导
- 当元素上的某个事件被触发后，其祖先元素上的相同事件也会同时被触发
- 冒泡的存在大大的简化了代码的编写，但在一些场景我们并不希望冒泡存在
  - 不希望事件冒泡时，可以通过事件对象来取消冒泡
- 时间的冒泡和元素的样式无关，和结构有关

在事件的响应函数中: event.target 表示的是触发事件的对象;this 绑定事件的对象

#### 事件的委派

思路: 可以将事件统一绑定给document，这样点击超链接时由于事件的冒泡，会导致document上的点击事件被触发，这样只绑定一次，所有的超链接都会具有这些事件

委派就是将本该绑定给多个元素的事件，统一绑定给document

#### 事件的捕获

事件的传播机制:

- 在DOM中事件的传播可以分为三个阶段:
  1. 捕获阶段(由祖先元素向目标元素进行事件的捕获)
  2. 目标阶段(触发事件的对象)
  3. 冒泡阶段(由目标元素向祖先元素进行事件的冒泡)

事件的捕获，指事件从外向内的传导，当我们当前元素触发事件以后，会先从当前元素最大的祖先元素开始向当前元素进行事件的捕获

如果希望在捕获阶段触发事件，可以将addEventListener的第三个参数设置为true,一般情况下我们不希望事件在捕获阶段触发，所以通常都不需要设置第三个参数

eventPhase 表示事件的阶段， 1 捕获阶段 2 目标阶段 3 冒泡阶段

### BOM对象(浏览器对象模型)

BOM为我们提供了一组对象，通过这组对象可以完成对浏览器的各种操作

BOM对象:

- Window -- 代表浏览器窗口(全局对象)
- Navigator -- 浏览器的对象(可以用来识别浏览器)
- Location -- 浏览器的地址栏信息
- History -- 浏览器的历史记录(控制浏览器前进后退)
- Screen -- 屏幕的信息

BOM对象都是作为window对象的属性保存的，所以可以直接在JS中访问这些对象

#### Navigator

userAgent 返回一个用来描述浏览器

#### location

location 表示的是浏览器地址栏的信息

- 可以直接将location的值修改为一个新的地址，这样会使得网页发生跳转
- location.assign() 跳转到一个新的网址
- location.reload() 刷新页面，可以传递一个true来强制清缓存
- location.href 获取当前地址
- location.replace() 跳转到一个新页面(无法通过回退按钮回退)

#### history

history.back()  回退

history.forward()  前进

history.go()  可以向前跳转，也可以向后跳转，正值前进，负值回退

#### 定时器

定时器的本质，就是在指定时间后将函数添加到消息队列中

通过定时器可以使代码在指定时间向后执行

设置定时器的方式有两种:

- setTimeout()
  - 参数:
    - 回调函数(要执行的代码)
    - 间隔的时间(毫秒)
  - 关闭定时器
    - clearTimeout()
- setInterval()(每隔一段时间代码就会执行一次)每间隔一段时间就将函数添加到消息队列中，但是如果函数执行的速度比较慢，它是无法确保每次执行的间隔都是一样的
  - 参数:
    - 回调函数(要执行的代码)
    - 间隔的时间(毫秒)
  - 关闭定时器
    - clearInterval()

### 事件循环(event loop)

函数在每次执行时，都会产生一个执行环境

执行环境负责存储函数执行时产生的一切数据

函数的执行环境存储到了一个叫做调用栈的地方，栈是一种数据结构，特点 后进先出

#### 调用栈(call stack)

- 调用栈负责存储函数的执行环境
- 当一个函数被调用时，它的执行环境会作为一个栈帧插入到调用栈的栈顶，函数执行完毕其栈帧会自动从栈中弹出

#### 队列

队列是一种数据结构，先进先出

消息队列

- 消息队列负责存储将要执行的函数
- 当我们触发一个事件时，其相应函数并不是直接就添加到调用栈中的，因为调用栈中有可能会存在一些还没有执行玩的代码
